CORS配置不当
CORS漏洞是指服务端配置不当，没有配置Access-Control-Allow-Origin等字段，导致攻击者能构造恶意脚本，诱导用户点击获取敏感信息
一般存在CORS漏洞都存在CSRF漏洞

CRLF注入
CRLF注入通常是发生在用户输入直接被构造到HTTP响应中，攻击者可以在HTTP响应中插入回车换行符，以执行恶意操作和欺骗用户
测试是否存在CRLF注入一般使用\r\n
如果存在WAF可以对其进行编码绕过，比如unicode编码、url编码、哈希编码等
或者往其加入大量垃圾字符，比如+符号等
或者使用一个无效的协议执行JS代码

CSRF漏洞
CSRF也就是跨站请求伪造，是一种挟持用户在已登录的web应用上执行非本意的操作
原理就是在Cookie未过期且未退出网站的情况下访问网站，会自动携带上Cookie
对于CSRF漏洞防御一般通过Referer、Origin和CSRF Token进行防御，但如果防御逻辑不当，则可进行绕过
比如在使用Referer校验时，对于域只是简单的校验存在域的字符串，则可以通过将其作为自己域的子域进行绕过
也有的应用程序当Referer请求头不存在时将跳过验证
Origin的情况和Referer类似，当对域校验不严谨时可进行绕过
当使用token进行验证时，有的应用程序只对POST请求进行验证，可以尝试改为GET请求进行尝试绕过
有的应用程序只校验token是否存在
也有的程序token没有绑定会话，使用的是token池，那么就可以用自己的账号获取一定的token进行CSRF漏洞利用
有的token放在了cookie里，这种情况会难以利用，需要结合CRLF注入更改cookie
当然这些防御也不是绝对的安全，如果网站还存在xss漏洞，将可能导致这些防御全线溃败

HTTP请求走私
HTTP请求走私源于前后端关于消息正文大小的分歧，攻击者在自己的请求中夹带一个请求，从而影响下一个请求
请求走私的种类有四种：
第一种是CL不为0的GET请求：当前端允许GET请求携带请求体，而后端不允许，则会忽略Content-Length，不进行处理，这就可能导致请求走私
第二种是请求包含2个Content-Length，当2个Content-Length值不同时，按照规范需要返回400，但有的服务器没有遵循规范，没有返回400，而是前端服务器取
第一个Content-Length，而后端服务器取第二个Content-Length，前后端取值不同时，就可能存在请求走私
第三种是请求中存在一个Content-Length，一个Transfer-Encoding，前端处理Content-Length，而后端处理Transfer-Encoding，值不同，就可能造成请求走私
第四种就是请求中有一个Content-Length，有两个Transfer-Encoding，而前后端都会处理Transfer-Encoding，可以对其中一个Transfer-Encoding的值进行乱写达成混淆
从而让前端或后端不处理Transfer-Encoding，本质上就是第二种和第三种方法
HTTP请求走私利用第一种利用就是HTTP请求头中比如User-Agent存在xss漏洞，借助HTTP请求走私能将危害扩大到其他用户而不是自有自己
第二种就是进行Web缓存投毒，比如一个网站的服务器会将一些静态资源缓存起来，下次访问从缓存中读取；那么第一个人修改包加入恶意数据，接下来的用户访问这些
资源则会加载这些恶意数据

JSON劫持
JSON劫持属于CSRF的范畴，当一个网站使用JSONP进行跨域传递敏感信息时，攻击者就能通过构造恶意的JSONP调用页面，诱导用户点击，获取用户的敏感信息
当输出的JSON没有严格定义Content-Type为application/json时，还可以通过callback输出点进行XSS
有的网站会使用Referer和token进行防御，但如果Referer对域验证不严谨，只检验是否存在指定域的字符串，则可进行绕过，有的网站当不存在Referer或者值为空时
不进行校验；如果token组成简单，容易爆破也可进行爆破绕过防御

JWT攻击
JWT攻击一般是伪造令牌、JWT信息泄露等
信息泄露就是对JWT进行解码时，其里面存在一些敏感信息
在进行伪造令牌时，第一种情况，有些开发为了方便开启了算法为None，上线了又忘记关了，则可将算法改为None进行伪造令牌
第二种情况，有的网站后端允许对称加密和非对称加密，当你获得公钥时，将非对称加密改为对称加密，可用公钥进行加密伪造令牌
第三种情况，可爆破JWT的私钥，进行令牌伪造

SQL注入
SQL注入通常发生在应用程序未能正确验证或转义用户输入的情况下，攻击者通过注入恶意的SQL语句，从而实现对数据库的非法访问和控制
SQL注入利用的第一步是找注入点，看是否可以注入，一般使用单引号和双引号，看页面是否有变化或者有没有报错信息来判断是否为注入点
第二步判断是数字型注入还是字符型注入，可以使用比如and 1=1、and 1=2来看页面的影响，如果有影响就是数字型注入，反之就是字符型注入
第三步，如果是字符型注入，就需要进行闭合，想办法进行闭合，让sql不报错
第四步就是判断sql的列数和显错位
第五步就是求库、求表、求字段、求数据；如果有回显，优先使用联合注入，如果没有回显，但有报错内容，则可以报错注入，如果都没有，但页面能判断真假，
可以使用布尔注入，三者都没有的话就尝试时间注入，也可以尝试DNS盲注，通过发送DNS请求看是否存在
当然有一些特殊的注入，比如堆叠注入，通过分号结束，然后加入一个新的sql，进行增删改
还有二次注入，恶意数据添加到数据库，被二次调用
第六步就是找后台路径
第七步就是上传getshell木马，然后连接
在这个过程中也会遇到WAF，就要进行WAF绕过，比如注释符绕过，大小写绕过，编码绕过，过滤的关键字替换等，这些就结合实际情况一个一个尝试

SSRF
SSRF也就是服务端请求伪造，是指攻击者欺骗服务器发起网络请求，可能导致对内部系统、外部服务或本地资源的未授权访问。
web服务器需要从别的服务器获取数据，比如：图片识别、图片拉取等，如果获取数据的服务器地址可控，攻击者可以通过web服务器自定义向别的服务器发出请求，
或者向内网服务器发送请求
SSRF的利用通常需要尝试多种协议来扩大危害，比如http/https、file、sftp等
如果是无回显型的就需要借助DNSlog平台来验证，如果不出网，可以通过请求响应时间判断内网资产是否存在来验证

URL跳转漏洞
URL跳转漏洞是指服务端未对传入的跳转URL变量进行检查和控制，导致攻击者诱导用户点击跳转到恶意网站
该漏洞一般存在业务完成处和用户交互处，比如注册账号，找回密码，登录登出，分享链接等
如果其存在白名单缺陷，
也可以利用正斜杠、反斜杠、问号、井号、@、其域作为自己域的子域、借助百度的多重跳、插入截断符、使用ip、ipv6、ip的8进制、十六进制转来绕过

XSS
XSS也就是跨站脚本攻击，这是一种将JS代码插入到其他用户页面中执行达到攻击目的的漏洞。
XSS漏洞有三种，分别是反射型、存储型、DOM型
反射型属于一次性攻击，攻击者将恶意代码放在链接中，目标用户点击该链接，服务器接收该请求并处理，然后将携带了XSS代码的数据发送到目标用户的浏览器，
浏览器解析该XSS代码，触发脚本，常见的地方在搜索栏处
存储型是持久型攻击，恶意代码会存储在数据库或文件中，XSS代码永久嵌入在页面中，所有访问该页面的用户都会成为受害者，常见的地方有论坛，留言、标签等
DOM型是针对JS代码的，不经过服务器进行交互，只会发生在客户端处理数据阶段。常见的地方就是对文档对象进行编辑，从而修改页面元素。
针对XSS的WAF绕过可以尝试第一种，传多个参数过去，有的服务器会将相同的参数进行拼接
第二种