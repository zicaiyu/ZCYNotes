CORS配置不当
CORS漏洞是指服务端配置不当，没有配置Access-Control-Allow-Origin等字段，导致攻击者能构造恶意脚本，诱导用户点击获取敏感信息
一般存在CORS漏洞都存在CSRF漏洞

CRLF注入
CRLF注入通常是发生在用户输入直接被构造到HTTP响应中，攻击者可以在HTTP响应中插入回车换行符，以执行恶意操作和欺骗用户
测试是否存在CRLF注入一般使用\r\n
如果存在WAF可以对其进行编码绕过，比如unicode编码、url编码、哈希编码等
或者往其加入大量垃圾字符，比如+符号等
或者使用一个无效的协议执行JS代码

CSRF漏洞
CSRF也就是跨站请求伪造，是一种挟持用户在已登录的web应用上执行非本意的操作
原理就是在Cookie未过期且未退出网站的情况下访问网站，会自动携带上Cookie
对于CSRF漏洞防御一般通过Referer、Origin和CSRF Token进行防御，但如果防御逻辑不当，则可进行绕过
比如在使用Referer校验时，对于域只是简单的校验存在域的字符串，则可以通过将其作为自己域的子域进行绕过
也有的应用程序当Referer请求头不存在时将跳过验证
Origin的情况和Referer类似，当对域校验不严谨时可进行绕过
当使用token进行验证时，有的应用程序只对POST请求进行验证，可以尝试改为GET请求进行尝试绕过
有的应用程序只校验token是否存在
也有的程序token没有绑定会话，使用的是token池，那么就可以用自己的账号获取一定的token进行CSRF漏洞利用
有的token放在了cookie里，这种情况会难以利用，需要结合CRLF注入更改cookie
当然这些防御也不是绝对的安全，如果网站还存在xss漏洞，将可能导致这些防御全线溃败

HTTP请求走私
HTTP请求走私源于前后端关于消息正文大小的分歧，攻击者在自己的请求中夹带一个请求，从而影响下一个请求
请求走私的种类有四种：
第一种是CL不为0的GET请求：当前端允许GET请求携带请求体，而后端不允许，则会忽略Content-Length，不进行处理，这就可能导致请求走私
第二种是请求包含2个Content-Length，当2个Content-Length值不同时，按照规范需要返回400，但有的服务器没有遵循规范，没有返回400，而是前端服务器取
第一个Content-Length，而后端服务器取第二个Content-Length，前后端取值不同时，就可能存在请求走私
第三种是请求中存在一个Content-Length，一个Transfer-Encoding，前端处理Content-Length，而后端处理Transfer-Encoding，值不同，就可能造成请求走私
第四种就是请求中有一个Content-Length，有两个Transfer-Encoding，而前后端都会处理Transfer-Encoding，可以对其中一个Transfer-Encoding的值进行乱写达成混淆
从而让前端或后端不处理Transfer-Encoding，本质上就是第二种和第三种方法